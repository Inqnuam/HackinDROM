//
//  filesHandler.swift
//  filesHandler
//
//  Created by Inqnuam on 13/08/2021.
//  Copyright Â© 2021 HackitALL. All rights reserved.
//

import Foundation

import SwiftUI
import Zip
func MakeReportZIP(_ folder: String, _ ocv: String, Kexts: [RunningKextsStruct], OpenCoreV: String, BootArgs: String) {

 
    let  MyDesktop = fileManager.urls(for: .desktopDirectory, in: .userDomainMask).first!.relativePath

    let filename = "ReportEFI_OC\(ocv)_" + String(Int.random(in: 13..<243))

    shell("cp -a '\(folder)/' '\(MyDesktop)/\(filename)/'") { result, _ in
      
        guard let config = fileManager.contents(atPath: "\(MyDesktop)/\(filename)/OC/config.plist") else { return }
       
//            var json = try PathExplorers.Plist(data: config)
//
//            try json.set("PlatformInfo", "Generic", "MLB", to: "Removed by HackinDROM")
//            try json.set("PlatformInfo", "Generic", "SystemSerialNumber", to: "Removed by HackinDROM")
//            try json.set("PlatformInfo", "Generic", "SystemUUID", to: "Removed by HackinDROM")
//
//            let readydata = try json.get().exportData()
//
//            try readydata.write(to: URL(fileURLWithPath: "\(MyDesktop)/\(filename)/OC/config.plist"))

            shell("system_profiler  -detailLevel mini -xml > '\(MyDesktop)/\(filename)/System_Report_Generated_by_HackinDROM.plist'") { result, _ in
                // #FIXME: -> Use HAPlistStruct instead of Scout
//                do {
//
//
//                    let sysRepDir = fileManager.contents(atPath: "\(MyDesktop)/\(filename)/System_Report_Generated_by_HackinDROM.plist")!
//                    var Report = try PathExplorers.Plist(data: sysRepDir)
//
//                    do {
//                    try Report.add(OpenCoreV, at: 13, "_items", 0, "OpenCore")
//                    } catch {
//
//                    }
//
//                    do {
//                        try Report.add(.dictionary(["Boot Arguments":.string(BootArgs)]), at: 13, "_items", .count)
//                    } catch {
//                      //  print(error)
//                    }
//
//                    var kextsBlock: ExplorerValue = [:]
//                    for Kext in Kexts {
//
//                        do {
//                            try kextsBlock.add(.string(Kext.version), at: PathElement(stringLiteral: Kext.name))
//                        } catch {
//                           // print(error)
//                        }
//
//
//
//                    }
//                    do {
//                    try Report.add(kextsBlock, at: 13, "_items", .count)
//                } catch {
//                   // print(error)
//                }
//                    try Report.add(.dictionary(["Generated by": .string("HackinDROM ðŸ§ª")]), at: 13, "_items", .count)
//
//
//                    let ExportingPlistDataSysRep = try Report.get().exportData()
//
//                    let outputURL = URL(fileURLWithPath: "\(MyDesktop)/\(filename)/System_Report_Generated_by_HackinDROM.plist")
//
//                    try ExportingPlistDataSysRep.write(to: outputURL)
//
//                    let newURL = outputURL.deletingPathExtension().appendingPathExtension("spx")
//
//                    try fileManager.moveItem(at: outputURL, to: newURL)
//
//                    try Zip.zipFiles(paths: [URL(fileURLWithPath: "\(MyDesktop)/\(filename)/")], zipFilePath: URL(fileURLWithPath: "\(MyDesktop)/\(filename).zip"), password: nil, progress: { (progress) -> Void in
//
//                        if progress == 1.0 {
//
//                            shell("rm -R '\(MyDesktop)/\(filename)'") { _, _ in
//
//                                SetNotif("Your Report EFI is ready!", "\(filename).zip on your Desktop!")
//                            }
//
//                        }
//                    }) // Zip
//                }

            }

        
    }

}

func FileUpload(_ filepath: String) -> String {

    var returnthis = "nul"
    shell("curl -F 'archive=@\(filepath)' 'https://hackindrom.zapto.org/app/upload' --silent | awk '{print $1 \" \"  $2}'") { result, _ in

        let req =  result.components(separatedBy: " ")
        if req[0] == "uploadok" {

            returnthis = req[1]
        }

    }

    return returnthis
}

func FileSelector(allowedFileTypes: [String], canCreateDirectories: Bool, canChooseFiles: Bool, canChooseDirectories: Bool, customTitle:String? = "Select a file" ) -> String {
    nc.post(name: Notification.Name("ClosePopover"), object: nil)
    var selectedfile  = ""

    let dialog = NSOpenPanel()

    dialog.title                   = customTitle
    dialog.showsResizeIndicator    = true
    dialog.showsHiddenFiles        = false
    dialog.allowsMultipleSelection = false
    dialog.canChooseDirectories = canChooseDirectories
    dialog.canChooseFiles = canChooseFiles
    dialog.allowedFileTypes        = allowedFileTypes
    dialog.isFloatingPanel         = true
    dialog.canDownloadUbiquitousContents = true
    dialog.canResolveUbiquitousConflicts = true
    dialog.canCreateDirectories = canCreateDirectories

    if dialog.runModal() ==  NSApplication.ModalResponse.OK {
        dialog.contentViewController?.view.window?.level = NSWindow.Level(rawValue: 17)
        dialog.contentViewController?.view.window?.makeFirstResponder(.none)
        let result = dialog.url // Pathname of the file

        if result != nil {
            selectedfile  = "nul"
            selectedfile  =  result!.path
            dialog.contentViewController?.view.window?.close()
            nc.post(name: Notification.Name("OpenPopover"), object: nil)
        }

    } else {
      
        dialog.contentViewController?.view.window?.close()
        nc.post(name: Notification.Name("OpenPopover"), object: nil)
        selectedfile  = "nul"
    }
    print(selectedfile)
    return selectedfile

}
func FileSaver(allowedFileTypes: [String], filename: String) -> String {
    nc.post(name: Notification.Name("ClosePopover"), object: nil)
    var selectedfile  = ""

    let dialog = NSSavePanel()

    dialog.title                   = "Choose a file"
    dialog.showsResizeIndicator    = true
    dialog.showsHiddenFiles        = false
    dialog.allowedFileTypes        = allowedFileTypes
    dialog.isFloatingPanel         = true
    dialog.canCreateDirectories = true
    dialog.nameFieldStringValue = filename

    if dialog.runModal() ==  NSApplication.ModalResponse.OK {
        dialog.contentViewController?.view.window?.level = NSWindow.Level(rawValue: 17)
        dialog.contentViewController?.view.window?.makeFirstResponder(.none)
        let result = dialog.url // Pathname of the file

        if result != nil {
            selectedfile  = "nul"
            selectedfile  =  result!.path
            dialog.contentViewController?.view.window?.close()
            nc.post(name: Notification.Name("OpenPopover"), object: nil)
        }

    } else {
        // User clicked on "Cancel"
     
        dialog.contentViewController?.view.window?.close()
        nc.post(name: Notification.Name("OpenPopover"), object: nil)
        selectedfile  = "nul"
    }

    return selectedfile

}

func multiFileSelector(allowedFileTypes: [String]) -> [String] {
    nc.post(name: Notification.Name("ClosePopover"), object: nil)
    var selectedfiles: [String] = []

    let dialog = NSOpenPanel()

    dialog.title                   = "Choose a file"
    dialog.showsResizeIndicator    = true
    dialog.showsHiddenFiles        = false
    dialog.allowsMultipleSelection = true
    dialog.canChooseDirectories = false
    dialog.canChooseFiles = true
    dialog.allowedFileTypes        = allowedFileTypes
    dialog.isFloatingPanel         = true
    dialog.canDownloadUbiquitousContents = true
    dialog.canResolveUbiquitousConflicts = true
    dialog.canCreateDirectories = false

    if dialog.runModal() ==  NSApplication.ModalResponse.OK {
        dialog.contentViewController?.view.window?.level = NSWindow.Level(rawValue: 17)
        dialog.contentViewController?.view.window?.makeFirstResponder(.none)
        let result = dialog.urls // Pathname of the file

        if !result.isEmpty {
         
            for file in result {
                
                selectedfiles.append(file.relativePath)
            }
            
            dialog.contentViewController?.view.window?.close()
            nc.post(name: Notification.Name("OpenPopover"), object: nil)
        }

    } else {
        // User clicked on "Cancel"
      
        dialog.contentViewController?.view.window?.close()
        nc.post(name: Notification.Name("OpenPopover"), object: nil)
      
    }

    return selectedfiles

}

func ImportFromFile(completion : @escaping (MyHackDataStrc)->()) {

    var PlatformInfo = MyHackDataStrc()

    let filePath =  FileSelector(allowedFileTypes: ["plist"], canCreateDirectories: false, canChooseFiles: true, canChooseDirectories: false)

    if filePath != "nul" {
      
           
        var isClover: Bool = false
            
        shell("perl -wln -e 'print if /\\bSmUUID\\b/' '\(filePath)'") { result, _ in
            isClover =  result.trimmingCharacters(in: .whitespacesAndNewlines) == "<key>SmUUID</key>"
 getHAPlistFrom(filePath) { plist in
                
             PlatformInfo.MLB =  plist.get( isClover ? ["SMBIOS", "BoardSerialNumber"] : ["PlatformInfo", "Generic", "MLB"])?.StringValue ?? ""
                PlatformInfo.ROM =  plist.get(isClover ? ["RtVariables", "ROM"] : [])?.StringValue ?? ""
                PlatformInfo.SystemProductName = plist.get(isClover ?  ["SMBIOS", "ProductName"] : ["PlatformInfo", "Generic", "MLB"])?.StringValue ?? ""
                PlatformInfo.SystemSerialNumber =  plist.get(isClover ? ["SMBIOS", "SerialNumber"]: ["PlatformInfo", "Generic", "SystemSerialNumber"])?.StringValue ?? ""
                PlatformInfo.SystemUUID =  plist.get(isClover ? ["SMBIOS", "SmUUID"]: ["PlatformInfo", "Generic", "SystemUUID"])?.StringValue ?? ""
                
                if isClover {
                    PlatformInfo.SIP = plist.get(["NVRAM", "Add", "7C436110-AB2A-4BBB-A880-FE41995C9F82", "csr-active-config"])?.StringValue ?? ""
                }
     completion(PlatformInfo)
            }
           
        }
    
    }

}



