//
//  filesHandler.swift
//  filesHandler
//
//  Created by Inqnuam on 13/08/2021.
//  Copyright Â© 2021 HackitALL. All rights reserved.
//

import Foundation
import Scout
import SwiftUI
import Zip
func MakeReportZIP(_ folder: String, _ ocv: String, Kexts: [RunningKextsStruct], OpenCoreV: String, BootArgs: String) {

 
    let  MyDesktop = fileManager.urls(for: .desktopDirectory, in: .userDomainMask).first!.relativePath

    let filename = "ReportEFI_OC\(ocv)_" + String(Int.random(in: 13..<243))

    shell("cp -a '\(folder)/' '\(MyDesktop)/\(filename)/'") { result, _ in
      
        guard let config = fileManager.contents(atPath: "\(MyDesktop)/\(filename)/OC/config.plist") else { return }
        do {
            var json = try PathExplorers.Plist(data: config)

            try json.set("PlatformInfo", "Generic", "MLB", to: "Removed by HackinDROM")
            try json.set("PlatformInfo", "Generic", "SystemSerialNumber", to: "Removed by HackinDROM")
            try json.set("PlatformInfo", "Generic", "SystemUUID", to: "Removed by HackinDROM")

            let readydata = try json.get().exportData()

            try readydata.write(to: URL(fileURLWithPath: "\(MyDesktop)/\(filename)/OC/config.plist"))

            shell("system_profiler  -detailLevel mini -xml > '\(MyDesktop)/\(filename)/System_Report_Generated_by_HackinDROM.plist'") { result, _ in

                do {

                    let sysRepDir = fileManager.contents(atPath: "\(MyDesktop)/\(filename)/System_Report_Generated_by_HackinDROM.plist")!
                    var Report = try PathExplorers.Plist(data: sysRepDir)

                    do {
                    try Report.add(OpenCoreV, at: 13, "_items", 0, "OpenCore")
                    } catch {
                        
                    }
                    
                    do {
                        try Report.add(.dictionary(["Boot Arguments":.string(BootArgs)]), at: 13, "_items", .count)
                    } catch {
                      //  print(error)
                    }
                    
                    var kextsBlock: ExplorerValue = [:]
                    for Kext in Kexts {

                        do {
                            try kextsBlock.add(.string(Kext.version), at: PathElement(stringLiteral: Kext.name))
                        } catch {
                           // print(error)
                        }
                       
                      

                    }
                    do {
                    try Report.add(kextsBlock, at: 13, "_items", .count)
                } catch {
                   // print(error)
                }
                    try Report.add(.dictionary(["Generated by": .string("HackinDROM ðŸ§ª")]), at: 13, "_items", .count)

                  
                    let ExportingPlistDataSysRep = try Report.get().exportData()

                    let outputURL = URL(fileURLWithPath: "\(MyDesktop)/\(filename)/System_Report_Generated_by_HackinDROM.plist")

                    try ExportingPlistDataSysRep.write(to: outputURL)

                    let newURL = outputURL.deletingPathExtension().appendingPathExtension("spx")
                  
                    try fileManager.moveItem(at: outputURL, to: newURL)

                    try Zip.zipFiles(paths: [URL(fileURLWithPath: "\(MyDesktop)/\(filename)/")], zipFilePath: URL(fileURLWithPath: "\(MyDesktop)/\(filename).zip"), password: nil, progress: { (progress) -> Void in

                        if progress == 1.0 {

                            shell("rm -R '\(MyDesktop)/\(filename)'") { _, _ in

                                SetNotif("Your Report EFI is ready!", "\(filename).zip on your Desktop!")
                            }

                        }
                    }) // Zip
                } catch {
                    print(error)
                }

            }

        } catch {

        }
    }

}

func FileUpload(_ filepath: String) -> String {

    var returnthis = "nul"
    shell("curl -F 'archive=@\(filepath)' 'https://hackindrom.zapto.org/app/upload' --silent | awk '{print $1 \" \"  $2}'") { result, _ in

        let req =  result.components(separatedBy: " ")
        if req[0] == "uploadok" {

            returnthis = req[1]
        }

    }

    return returnthis
}

func FileSelector(allowedFileTypes: [String], canCreateDirectories: Bool, canChooseFiles: Bool, canChooseDirectories: Bool, customTitle:String? = "Select a file" ) -> String {
    nc.post(name: Notification.Name("ClosePopover"), object: nil)
    var selectedfile  = ""

    let dialog = NSOpenPanel()

    dialog.title                   = customTitle
    dialog.showsResizeIndicator    = true
    dialog.showsHiddenFiles        = false
    dialog.allowsMultipleSelection = false
    dialog.canChooseDirectories = canChooseDirectories
    dialog.canChooseFiles = canChooseFiles
    dialog.allowedFileTypes        = allowedFileTypes
    dialog.isFloatingPanel         = true
    dialog.canDownloadUbiquitousContents = true
    dialog.canResolveUbiquitousConflicts = true
    dialog.canCreateDirectories = canCreateDirectories

    if dialog.runModal() ==  NSApplication.ModalResponse.OK {
        dialog.contentViewController?.view.window?.level = NSWindow.Level(rawValue: 17)
        dialog.contentViewController?.view.window?.makeFirstResponder(.none)
        let result = dialog.url // Pathname of the file

        if result != nil {
            selectedfile  = "nul"
            selectedfile  =  result!.path
            dialog.contentViewController?.view.window?.close()
            nc.post(name: Notification.Name("OpenPopover"), object: nil)
        }

    } else {
      
        dialog.contentViewController?.view.window?.close()
        nc.post(name: Notification.Name("OpenPopover"), object: nil)
        selectedfile  = "nul"
    }
    print(selectedfile)
    return selectedfile

}
func FileSaver(allowedFileTypes: [String], filename: String) -> String {
    nc.post(name: Notification.Name("ClosePopover"), object: nil)
    var selectedfile  = ""

    let dialog = NSSavePanel()

    dialog.title                   = "Choose a file"
    dialog.showsResizeIndicator    = true
    dialog.showsHiddenFiles        = false
    dialog.allowedFileTypes        = allowedFileTypes
    dialog.isFloatingPanel         = true
    dialog.canCreateDirectories = true
    dialog.nameFieldStringValue = filename

    if dialog.runModal() ==  NSApplication.ModalResponse.OK {
        dialog.contentViewController?.view.window?.level = NSWindow.Level(rawValue: 17)
        dialog.contentViewController?.view.window?.makeFirstResponder(.none)
        let result = dialog.url // Pathname of the file

        if result != nil {
            selectedfile  = "nul"
            selectedfile  =  result!.path
            dialog.contentViewController?.view.window?.close()
            nc.post(name: Notification.Name("OpenPopover"), object: nil)
        }

    } else {
        // User clicked on "Cancel"
     
        dialog.contentViewController?.view.window?.close()
        nc.post(name: Notification.Name("OpenPopover"), object: nil)
        selectedfile  = "nul"
    }

    return selectedfile

}

func multiFileSelector(allowedFileTypes: [String]) -> [String] {
    nc.post(name: Notification.Name("ClosePopover"), object: nil)
    var selectedfiles: [String] = []

    let dialog = NSOpenPanel()

    dialog.title                   = "Choose a file"
    dialog.showsResizeIndicator    = true
    dialog.showsHiddenFiles        = false
    dialog.allowsMultipleSelection = true
    dialog.canChooseDirectories = false
    dialog.canChooseFiles = true
    dialog.allowedFileTypes        = allowedFileTypes
    dialog.isFloatingPanel         = true
    dialog.canDownloadUbiquitousContents = true
    dialog.canResolveUbiquitousConflicts = true
    dialog.canCreateDirectories = false

    if dialog.runModal() ==  NSApplication.ModalResponse.OK {
        dialog.contentViewController?.view.window?.level = NSWindow.Level(rawValue: 17)
        dialog.contentViewController?.view.window?.makeFirstResponder(.none)
        let result = dialog.urls // Pathname of the file

        if !result.isEmpty {
         
            for file in result {
                
                selectedfiles.append(file.relativePath)
            }
            
            dialog.contentViewController?.view.window?.close()
            nc.post(name: Notification.Name("OpenPopover"), object: nil)
        }

    } else {
        // User clicked on "Cancel"
      
        dialog.contentViewController?.view.window?.close()
        nc.post(name: Notification.Name("OpenPopover"), object: nil)
      
    }

    return selectedfiles

}

func ImportFromFile(completion : @escaping (MyHackDataStrc)->()) {

    var PlatformInfo = MyHackDataStrc()

    let FilePath =  FileSelector(allowedFileTypes: ["plist"], canCreateDirectories: false, canChooseFiles: true, canChooseDirectories: false)

    if FilePath != "nul" {
        if let config = fileManager.contents(atPath: FilePath) {
            // #FIXME -> Use HAPlistStruct instead of Scout
        var isClover: Bool = false
        shell("perl -wln -e 'print if /\\bSmUUID\\b/' '\(FilePath)'") { result, _ in
            isClover =  result.trimmingCharacters(in: .whitespacesAndNewlines) == "<key>SmUUID</key>"

            do {

                let json = try PathExplorers.Plist(data: config)
                if isClover {
                    PlatformInfo.SystemProductName = try json.get("SMBIOS", "ProductName").string ?? ""
                    PlatformInfo.MLB = try json.get("SMBIOS", "BoardSerialNumber").string ?? ""
                    PlatformInfo.ROM = Base64toHex(try json.get("RtVariables", "ROM").data?.base64EncodedString() ?? "")
                    PlatformInfo.SystemSerialNumber = try json.get("SMBIOS", "SerialNumber").string ?? ""
                    PlatformInfo.SystemUUID = try json.get("SMBIOS", "SmUUID").string ?? ""

                } else {

                    PlatformInfo.MLB = try json.get("PlatformInfo", "Generic", "MLB").string!
                    PlatformInfo.ROM =  Base64toHex(try json.get("PlatformInfo", "Generic", "ROM").data?.base64EncodedString()  ?? "")
                    PlatformInfo.SystemProductName =  try json.get("PlatformInfo", "Generic", "SystemProductName").string ?? ""
                    PlatformInfo.SystemSerialNumber = try json.get("PlatformInfo", "Generic", "SystemSerialNumber").string ?? ""
                    PlatformInfo.SystemUUID = try json.get("PlatformInfo", "Generic", "SystemUUID").string ?? ""
                    PlatformInfo.SIP = Base64toHex( try json.get("NVRAM", "Add", "7C436110-AB2A-4BBB-A880-FE41995C9F82", "csr-active-config").data?.base64EncodedString() ?? "")

                }
                completion(PlatformInfo)
            } catch {
                print(error)
            }

           
        }
    }
    }

}



